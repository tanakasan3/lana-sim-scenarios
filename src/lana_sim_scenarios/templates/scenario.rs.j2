//! Scenario: {{ scenario.name }}
//! {{ scenario.description }}
//! Generated by lana-sim-scenarios

use std::time::Duration;

use es_entity::clock::{ClockController, ClockHandle};
use futures::StreamExt;
use lana_app::{app::LanaApp, primitives::*};
use lana_events::{CoreCreditCollectionEvent, CoreCreditEvent, LanaEvent};
use rust_decimal_macros::dec;
use tracing::{event, instrument};

use crate::helpers;

const ONE_DAY: Duration = Duration::from_secs(86400);
const EVENT_WAIT_TIMEOUT: Duration = Duration::from_millis(100);

#[instrument(
    name = "sim_bootstrap.{{ scenario.fn_name }}_scenario",
    skip(app, clock, clock_ctrl),
    err
)]
pub async fn {{ scenario.fn_name }}_scenario(
    sub: Subject,
    app: &LanaApp,
    clock: &ClockHandle,
    clock_ctrl: &ClockController,
) -> anyhow::Result<()> {
    event!(tracing::Level::INFO, "Starting {{ scenario.name }} scenario");

    let mut stream = app.outbox().listen_persisted(None);

{% for action in actions %}
{% if action.wait_days > 0 %}
    // Advance time: {{ action.wait_days }} days
    for _ in 0..{{ action.wait_days }} {
        clock_ctrl.advance(ONE_DAY).await;
    }
{% endif %}

{% if action.action_type == "create_customer" %}
    // Create customer: {{ action.entity }}
    let ({{ action.entity }}_id, {{ action.entity }}_deposit_id) = 
        helpers::create_customer(&sub, app, "{{ action.params.suffix }}").await?;
{% elif action.action_type == "make_deposit" %}
    // Make deposit for {{ action.params.entity }}
    let deposit_amount = UsdCents::try_from_usd(dec!({{ action.params.amount_usd }}))?;
    helpers::make_deposit(&sub, app, &{{ action.params.entity.replace('_deposit', '') }}_id, deposit_amount).await?;
{% elif action.action_type == "create_proposal" %}
    // Create facility proposal
    let cf_terms = helpers::std_terms();  // TODO: customize terms from {{ action.params.get('terms', {}) }}
    let cf_amount = UsdCents::try_from_usd(dec!({{ action.params.amount_usd }}))?;
    let cf_proposal = app
        .create_facility_proposal(&sub, {{ action.params.get('customer_ref', 'customer_1') }}_id, cf_amount, cf_terms, None::<CustodianId>)
        .await?;
    let proposal_id = cf_proposal.id;
    let cf_id: CreditFacilityId = proposal_id.into();
{% elif action.action_type == "conclude_customer_approval" %}
    // Customer approves proposal
    app.credit()
        .proposals()
        .conclude_customer_approval(&sub, proposal_id, true)
        .await?;
{% elif action.action_type == "wait_for_approval" %}
    // Wait for approval process to conclude
    loop {
        tokio::select! {
            Some(msg) = stream.next() => {
                if let Some(LanaEvent::Credit(CoreCreditEvent::FacilityProposalConcluded {
                    entity,
                })) = &msg.payload
                    && entity.status == CreditFacilityProposalStatus::Approved
                    && entity.id == proposal_id
                {
                    msg.inject_trace_parent();
                    break;
                }
            }
            _ = tokio::time::sleep(EVENT_WAIT_TIMEOUT) => {
                clock_ctrl.advance(ONE_DAY).await;
            }
        }
    }
{% elif action.action_type == "update_collateral" %}
    // Update collateral (standalone)
    // Note: This requires an existing pending facility
    // TODO: Track collateral_id properly
{% elif action.action_type == "update_collateral_for_activation" %}
    // Update collateral to trigger facility activation
    let pending_facility = app
        .credit()
        .pending_credit_facilities()
        .find_by_id(&sub, proposal_id)
        .await?
        .expect("pending facility exists");

    app.credit()
        .collaterals()
        .update_collateral_by_id(
            &sub,
            pending_facility.collateral_id,
            Satoshis::from({{ action.params.satoshis }}_u64),
            clock.today(),
        )
        .await?;
{% elif action.action_type == "wait_for_facility_activation" %}
    // Wait for facility activation
    loop {
        tokio::select! {
            Some(msg) = stream.next() => {
                if let Some(LanaEvent::Credit(CoreCreditEvent::FacilityActivated { entity })) = &msg.payload
                    && entity.id == cf_id
                {
                    msg.inject_trace_parent();
                    break;
                }
            }
            _ = tokio::time::sleep(EVENT_WAIT_TIMEOUT) => {
                clock_ctrl.advance(ONE_DAY).await;
            }
        }
    }
{% elif action.action_type == "initiate_disbursal" %}
    // Initiate disbursal
    app.credit()
        .initiate_disbursal(&sub, cf_id, UsdCents::try_from_usd(dec!({{ action.params.amount_usd }}))?)
        .await?;
{% elif action.action_type == "wait_for_disbursal" %}
    // Wait for disbursal to settle
    loop {
        tokio::select! {
            Some(msg) = stream.next() => {
                if let Some(LanaEvent::Credit(CoreCreditEvent::DisbursalSettled { entity })) = &msg.payload
                    && entity.credit_facility_id == cf_id
                {
                    msg.inject_trace_parent();
                    break;
                }
            }
            _ = tokio::time::sleep(EVENT_WAIT_TIMEOUT) => {
                clock_ctrl.advance(ONE_DAY).await;
            }
        }
    }
{% elif action.action_type == "record_payment" %}
    // Record payment
    app.record_payment_with_date(&sub, cf_id, UsdCents::try_from_usd(dec!({{ action.params.amount_usd }}))?, clock.today()).await?;
{% elif action.action_type == "complete_facility" %}
    // Complete facility
    app.credit().complete_facility(&sub, cf_id).await?;
{% elif action.action_type == "advance_time" %}
    // Time advancement (handled by wait_days above)
{% elif action.action_type == "comment" %}
    // {{ action.params.text }}
{% elif action.action_type == "create_terms_template" %}
    // Create terms template (using default)
{% endif %}
{% endfor %}

    event!(tracing::Level::INFO, "Completed {{ scenario.name }} scenario");
    Ok(())
}
